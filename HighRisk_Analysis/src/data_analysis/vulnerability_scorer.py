import pandas as pd
import numpy as np
from datetime import datetime


class VulnerabilityScorer:
    VulnSeverityScoreDef = {'1': 1, '2': 2, '3': 3, '4': 4, '5': 5}
    VulnPatchReleasedDaysScoreDef = {'NoPatch': 5, 'Within30days': 3, 'Morethan30days': 1, 'Future': 0}
    VulnStatusScoreDef = {'ACTIVE': 5, 'CLOSED': 0}
    VulnDetAgeScoreDef = {'7days': 1, '30days': 2, '60days': 3, 'Morethan60days': 4}
    VulnDetTimesScoreDef = {'Zero': 0, 'One': 1, 'LessThan5': 2, 'MoreThan5': 3}
    VulnPatchScoreDef = {'Yes': 0, 'No': 5}

    def __init__(self, df):
        self.df = df

    @staticmethod
    def calculate_minmax(df, minmaxcols):
        # Check if all specified columns are in the DataFrame
        for col in minmaxcols:
            if col not in df.columns:
                raise ValueError(f"Column '{col}' not found in input df.")
        
        # Extract the columns and convert them to NumPy arrays
        data = df[minmaxcols].to_numpy()
        
        # Calculate min and max values for each column
        mins = np.min(data, axis=0)
        maxs = np.max(data, axis=0)

        return mins, maxs

    def _fn_patch(self, dt):
        """Categorize patch based on release date."""
        if pd.isna(dt):
            return 'NoPatch'

        now = pd.Timestamp(datetime.now())
        dt2 = pd.to_datetime(dt, format='%d-%b-%y')

        result = (
            "Future" if (now - dt2).days < 0 else
            "Within30days" if (now - dt2).days <= 30 else
            "Morethan30days"
        )
        return result

    def _fn_det_age(self, dys):
        """Categorize detection age."""
        if pd.isna(dys):
            return 'NoDays'

        result = (
            "7days" if dys <= 7 else
            "30days" if dys <= 30 else
            "60days" if dys <= 60 else
            "Morethan60days"
        )
        return result

    def _fn_det_times(self, cnt):
        """Categorize detection times."""
        if pd.isna(cnt):
            return 'Zero'

        result = (
            "Zero" if cnt == 0 else
            "One" if cnt <= 1 else
            "LessThan5" if cnt <= 5 else
            "MoreThan5"
        )
        return result

    def add_score_def_columns(self):
        """Add calculated score definition columns to the dataframe."""
        self.df['v_severity'] = self.df['Severity']
        self.df['v_patchReleaseDt'] = self.df['Patch Released'].apply(self._fn_patch)
        self.df['v_detAge'] = self.df['Detection AGE'].apply(self._fn_det_age)
        self.df['v_detTimes'] = self.df['Times Detected'].apply(self._fn_det_times)

    def calculate_vulnerability_stability(self):
        """Calculate the overall vulnerability score and stability."""
       
        self.add_score_def_columns()

        # Add individual score components to the dataframe
        self.df['vulnerability_severity_score'] = self.df['v_severity']
        self.df['vulnerability_patchReleased_score'] = self.df.apply(lambda row: self.VulnPatchReleasedDaysScoreDef.get(row['v_patchReleaseDt'], 0), axis=1)
        self.df['vulnerability_status_score'] = self.df.apply(lambda row: self.VulnStatusScoreDef.get(row['Status'], 0), axis=1)
        self.df['vulnerability_detectedAge_score'] = self.df.apply(lambda row: self.VulnDetAgeScoreDef.get(row['v_detAge'], 0), axis=1)
        self.df['vulnerability_detectedTimes_score'] = self.df.apply(lambda row: self.VulnDetTimesScoreDef.get(row['v_detTimes'], 0), axis=1)
        self.df['vulnerability_patch_score'] = self.df.apply(lambda row: self.VulnPatchScoreDef.get(row['Vuln Patchable'], 0), axis=1)
        
        aggregated_df = self.df.groupby('asset_id').agg(
           vulnerability_severity_score=('vulnerability_severity_score', 'mean'),
           vulnerability_patchReleased_score=('vulnerability_patchReleased_score', 'mean'),
           vulnerability_status_score=('vulnerability_status_score', 'mean'),
           vulnerability_detectedAge_score=('vulnerability_detectedAge_score', 'mean'),
           vulnerability_detectedTimes_score=('vulnerability_detectedTimes_score', 'mean'),
           vulnerability_patch_score=('vulnerability_patch_score', 'mean'),
           vulnerability_count=('asset_id', 'size')  
        ).reset_index()

        # Step 3: Calculate the overall vulnerability score by multiplying with the count of vulnerabilities
        aggregated_df['vulnerability_score'] = (
                aggregated_df['vulnerability_severity_score'] +
                aggregated_df['vulnerability_patchReleased_score'] +
                aggregated_df['vulnerability_status_score'] +
                aggregated_df['vulnerability_detectedAge_score'] +
                aggregated_df['vulnerability_detectedTimes_score'] +
                aggregated_df['vulnerability_patch_score']
            ) * aggregated_df['vulnerability_count']  

        # Step 4: Calculate the overall_vuln_score by normalizing vuln_score with max(vuln_score)
        max_vulnerability_score = aggregated_df['vulnerability_score'].max()
        aggregated_df['overall_vulnerability_score'] = aggregated_df['vulnerability_score'] / max_vulnerability_score
    
        return aggregated_df

    def generate_vulnerability_summary(self):
        """Generate a summary of vulnerability scores per asset."""
        grouped = self.df.groupby('asset_id')
        
        results = []
        for asset_id, group in grouped:
            results.append({
                'asset_id': asset_id,
                'vuln_count': np.mean(group['asset_id'].count()),
                'vuln_severity_score': np.sum(group['VulnSeverityScore'].to_numpy()),
                'vuln_patchReleased_score': np.sum(group['VulnPatchReleasedDaysScore'].to_numpy()),
                'vuln_status_score': np.sum(group['VulnStatusScore'].to_numpy()),
                'vuln_detectedAge_score': np.sum(group['VulnDetAgeScore'].to_numpy()),
                'vuln_detectedTimes_score': np.sum(group['VulnDetTimesScore'].to_numpy()),
                'vuln_patch_score': np.sum(group['VulnPatchScore'].to_numpy()),
                'overall_vuln_score': np.sum(group['vuln_score'].to_numpy())
            })

        results_df = pd.DataFrame(results)
        mins_ovs, maxs_ovs = self.calculate_minmax(results_df, ['overall_vuln_score'])
        results_df['n_vuln_score'] = results_df['overall_vuln_score'] / maxs_ovs[0]
        return results_df
